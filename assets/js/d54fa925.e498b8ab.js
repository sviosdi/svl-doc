"use strict";(self.webpackChunksvl_doc=self.webpackChunksvl_doc||[]).push([[582],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var o=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var r=o.createContext({}),c=function(e){var n=o.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(r.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,r=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=s,g=p["".concat(r,".").concat(m)]||p[m]||d[m]||a;return t?o.createElement(g,i(i({ref:n},u),{},{components:t})):o.createElement(g,i({ref:n},u))}));function g(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,i=new Array(a);i[0]=m;var l={};for(var r in n)hasOwnProperty.call(n,r)&&(l[r]=n[r]);l.originalType=e,l[p]="string"==typeof e?e:s,i[1]=l;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3920:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=t(7462),s=(t(7294),t(3905));const a={sidebar_position:1},i="Signal",l={unversionedId:"signaux&slots/Signaux",id:"signaux&slots/Signaux",title:"Signal",description:"Un signal est une fonction particuli\xe8re qui peut \xeatre connect\xe9e \xe0 diff\xe9rentes fonctions ou m\xe9thodes d'un objet (instance d'une classe). Lorsque cette fonction",source:"@site/docs/signaux&slots/Signaux.mdx",sourceDirName:"signaux&slots",slug:"/signaux&slots/Signaux",permalink:"/svl-doc/docs/signaux&slots/Signaux",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Signaux & Slots",permalink:"/svl-doc/docs/category/signaux--slots"},next:{title:"Signaux & Slots",permalink:"/svl-doc/docs/signaux&slots/"}},r={},c=[{value:"<strong>En synth\xe8se</strong> :",id:"en-synth\xe8se-",level:2},{value:"Connexion-\xe9mission-d\xe9connexion d&#39;un signal",id:"connexion-\xe9mission-d\xe9connexion-dun-signal",level:2},{value:"\xe0 une fonction",id:"\xe0-une-fonction",level:3},{value:"\xe0 une m\xe9thode",id:"\xe0-une-m\xe9thode",level:3},{value:"D\xe9connecter tout un objet d&#39;un signal.",id:"d\xe9connecter-tout-un-objet-dun-signal",level:2},{value:"D\xe9connecter tous les slots d&#39;un signal",id:"d\xe9connecter-tous-les-slots-dun-signal",level:2},{value:"D\xe9connecter tous les signaux connect\xe9s \xe0 un objet.",id:"d\xe9connecter-tous-les-signaux-connect\xe9s-\xe0-un-objet",level:2}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"signal"},"Signal"),(0,s.kt)("p",null,"#include ",(0,s.kt)("a",{parentName:"p",href:"https://gitlab.com/sviosdi/signals_slots/-/blob/main/include/Signal.hpp"},'"Signal.hpp"')),(0,s.kt)("p",null,"Un signal est une fonction particuli\xe8re qui peut \xeatre connect\xe9e \xe0 diff\xe9rentes fonctions ou m\xe9thodes d'un objet (instance d'une classe). Lorsque cette fonction\nest ex\xe9cut\xe9e, on dit alors que le signal est ",(0,s.kt)("em",{parentName:"p"},"\xe9mis"),", toutes les fonctions/m\xe9thodes qui lui sont connect\xe9es, nomm\xe9es traditionnellement ",(0,s.kt)("em",{parentName:"p"},"slots"),", seront appel\xe9es\net ex\xe9cut\xe9es avec les param\xe8tres transmis par le signal."),(0,s.kt)("p",null,"Un signal ",(0,s.kt)("inlineCode",{parentName:"p"},"sig")," prenant des param\xe8tres ",(0,s.kt)("inlineCode",{parentName:"p"},"params")," peut ainsi \xeatre connect\xe9 \xe0 toute fonction ou toute m\xe9thode d'une classe, \xe0 condition que cette fonction/m\xe9thode\nprenne des param\xe8tres de types correspondants aux types des param\xe8tres ",(0,s.kt)("inlineCode",{parentName:"p"},"params"),". Lorsque le signal est ",(0,s.kt)("em",{parentName:"p"},"\xe9mis")," toutes les fonctions ou m\xe9thodes connect\xe9es\nsont alors ex\xe9cut\xe9es avec les param\xe8tres ",(0,s.kt)("em",{parentName:"p"},"transmis")," par le signal."),(0,s.kt)("p",null,"Le constructeur d'un signal n'a pas de param\xe8tres. Il faut par contre d\xe9finir les types\ndes param\xe8tres du signal comme une liste de param\xe8tres du patron de la classe ",(0,s.kt)("inlineCode",{parentName:"p"},"Signal"),"."),(0,s.kt)("p",null,"Par exemple, le signal :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"Signal<int> sig1;\n")),(0,s.kt)("p",null,"peut \xeatre connect\xe9 \xe0 une fonction ou une m\xe9thode dont le param\xe8tre est un ",(0,s.kt)("inlineCode",{parentName:"p"},"int")," :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"void add(int)                // slot fonction\nvoid setErrorMessage(int)    // slot fonction\nvoid A::seek(int)            // slot m\xe9thode d'une classe A\n")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Les fonctions/m\xe9thodes jouant le r\xf4le de slots peuvent retourner une valeur, cependant cette valeur ne sera pas exploitable lors de l'\xe9mission du signal.\nPour cette raison les slots retourneront g\xe9n\xe9ralement ",(0,s.kt)("inlineCode",{parentName:"p"},"void"),".")),(0,s.kt)("p",null,"La connexion se fait alors par la m\xe9thode ",(0,s.kt)("inlineCode",{parentName:"p"},"connect()")," du signal :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"sig1.connect(add);\nsig1.connect(getErrorMessage);\nsig1.connect(&a, &A::seek);       // a \xe9tant une instance d'une classe A\n")),(0,s.kt)("p",null,"Au d\xe9clenchement du signal par :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"sig1(51);\n")),(0,s.kt)("p",null,"les fonctions ou m\xe9thode suivantes sont alors ex\xe9cut\xe9es :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"add(51)\nsetErrorMessage(51)\na.seek(51)\n")),(0,s.kt)("p",null,"Un signal peut \xeatre d\xe9connect\xe9 d'une fonction ou d'une m\xe9thode par la m\xe9thode ",(0,s.kt)("inlineCode",{parentName:"p"},"disconnect()")," du signal."),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"Si un objet connect\xe9 est d\xe9truit, la m\xe9thode connect\xe9e sera tout de m\xeame appel\xe9e \xe0 l'\xe9mission du signal. Ceci conduit \xe0 un comportement impr\xe9visible\n(crash ou m\xe9thode d'un objet qui n'existe plus qui continue a \xeatre appel\xe9e...). Avant la destruction de l'objet il est donc imp\xe9ratif de d\xe9connecter tous les signaux\nqui lui sont connect\xe9s. Cela impose de se souvenir de tous les signaux connect\xe9s \xe0 cet objet pour pouvoir les d\xe9connecter.\nSi on sait lors de la conception d'une classe, que les instances de cette classe seront amen\xe9es \xe0 avoir des m\xe9thodes connect\xe9es \xe0 des signaux, c-\xe0-d jouant\nle r\xf4le de ",(0,s.kt)("em",{parentName:"p"},"slots"),", on pourra alors de mani\xe8re plus efficace, et de pr\xe9f\xe9rence, faire d\xe9river cette classe de la classe ",(0,s.kt)("inlineCode",{parentName:"p"},"NsObject"),". Tous les signaux connect\xe9s seront alors\nautomatiquement enregistr\xe9s par l'objet lors de leur connexion et automatiquement d\xe9connect\xe9s lors de la destruction de l'objet.")),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"La notion de ",(0,s.kt)("inlineCode",{parentName:"p"},"slot")," ( fichier ",(0,s.kt)("inlineCode",{parentName:"p"},"Slot.hpp")," ) n'a d'int\xe9r\xeat que pour le d\xe9veloppeur de Svl. Elle est invisible lors de l'utilisation des signaux et le\nfichier ",(0,s.kt)("inlineCode",{parentName:"p"},"Slot.hpp")," n'a pas a \xeatre inclus par l'utilisateur. Pour l'utilisateur un slot est une fonction ou m\xe9thode quelconque.")),(0,s.kt)("h2",{id:"en-synth\xe8se-"},(0,s.kt)("strong",{parentName:"h2"},"En synth\xe8se")," :"),(0,s.kt)("h2",{id:"connexion-\xe9mission-d\xe9connexion-dun-signal"},"Connexion-\xe9mission-d\xe9connexion d'un signal"),(0,s.kt)("h3",{id:"\xe0-une-fonction"},"\xe0 une fonction"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"void f(int){ .... }\nsvl::Signal<int>  sig;\nsig.connect(&f);\nsig.connect(f); // \xe9galement correct\nsig(57); // \xe9mission du signal\nsig.disconnect(f);\n")),(0,s.kt)("h3",{id:"\xe0-une-m\xe9thode"},"\xe0 une m\xe9thode"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class A {\npublic:\n    A(...) { ...}\n    void m(int, std::string) {\n        ....\n    }\n}\n\nA a(...);\nsvl::Signal<int, std::string>  sig;\nsig.connect(&a, &A::m);\nsig(57, \"ok\"); //  \xe9mission du signal\nsig.disconnect(&a, &A::m);\n// la ligne suivante d\xe9connecte m mais aussi toute autre m\xe9thode de l'objet\n// qui aurait \xe9t\xe9 \xe9ventuellement aussi connect\xe9 au signal. Ce n'est pas n\xe9cessairement\n// ce que l'on veut. De plus, m\xeame s'il n'y a qu'une m\xe9thode connect\xe9e, c'est moins\n// efficace (rapide) que la ligne pr\xe9c\xe9dente.\nsig.disconnect(&a);\n")),(0,s.kt)("h2",{id:"d\xe9connecter-tout-un-objet-dun-signal"},"D\xe9connecter tout un objet d'un signal."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"public:\n    A(...) { ...}\n    void m1(int) {\n        ....\n    }\n    void m2(int) {\n        ...\n    }\n}\n\nA a(...);\nsvl::Signal<int>  sig;\nsig.connect(&a, &A::m1);\nsig.connect(&a, &A::m2);\nsig.disconnect(&a); // d\xe9connecte m1 et m2\n")),(0,s.kt)("h2",{id:"d\xe9connecter-tous-les-slots-dun-signal"},"D\xe9connecter tous les slots d'un signal"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class A {\npublic:\n    A() { ...}\n    void m() {\n        ....\n    }\n}\n\nvoid f() {}\nint g() {}\n\nA a;\nSignal<> sig;\nsig.connect(&a; &A::m);\nsig.connect(&f);\nsig.connect(&g);\nsig.disconnectAll(); // d\xe9connecte toutes les connexions pr\xe9c\xe9dentes\n\n")),(0,s.kt)("h2",{id:"d\xe9connecter-tous-les-signaux-connect\xe9s-\xe0-un-objet"},"D\xe9connecter tous les signaux connect\xe9s \xe0 un objet."),(0,s.kt)("p",null,"Il faut le faire manuellement, \xe0 moins que l'objet en question ne d\xe9rive de la classe ",(0,s.kt)("inlineCode",{parentName:"p"},"Object"),". Dans ce cas, \xe0 la destruction de\nl'objet, tous les signaux qui lui sont connect\xe9s seront d\xe9connect\xe9s automatiquement."))}p.isMDXComponent=!0}}]);