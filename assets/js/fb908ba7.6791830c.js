"use strict";(self.webpackChunksvl_doc=self.webpackChunksvl_doc||[]).push([[75],{3905:(e,n,a)=>{a.d(n,{Zo:()=>d,kt:()=>k});var r=a(7294);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var o=r.createContext({}),p=function(e){var n=r.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},d=function(e){var n=p(e.components);return r.createElement(o.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(a),m=t,k=u["".concat(o,".").concat(m)]||u[m]||c[m]||i;return a?r.createElement(k,l(l({ref:n},d),{},{components:a})):r.createElement(k,l({ref:n},d))}));function k(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=a.length,l=new Array(i);l[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[u]="string"==typeof e?e:t,l[1]=s;for(var p=2;p<i;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7851:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=a(7462),t=(a(7294),a(3905));const i={description:"RulesParser",title:"Code de RulesParser",sidebar_position:2,keywords:["grammar","rules","parser"],sidebar_label:"RulesParser",sidebar_class_name:"dev-icon"},l=void 0,s={unversionedId:"RulesParser/code",id:"RulesParser/code",title:"Code de RulesParser",description:"RulesParser",source:"@site/docs/RulesParser/code.mdx",sourceDirName:"RulesParser",slug:"/RulesParser/code",permalink:"/svl-doc/docs/RulesParser/code",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"RulesParser",title:"Code de RulesParser",sidebar_position:2,keywords:["grammar","rules","parser"],sidebar_label:"RulesParser",sidebar_class_name:"dev-icon"},sidebar:"tutorialSidebar",previous:{title:"Utilisation de RulesParser",permalink:"/svl-doc/docs/RulesParser/"}},o={},p=[{value:"Analyse de la grammaire et g\xe9n\xe9ration du code",id:"analyse-de-la-grammaire-et-g\xe9n\xe9ration-du-code",level:2},{value:"La classe <code>RulesParser</code>",id:"la-classe-rulesparser",level:3},{value:"Le code g\xe9n\xe9r\xe9 et son utilisation.",id:"le-code-g\xe9n\xe9r\xe9-et-son-utilisation",level:2},{value:"Transcription des r\xe8gles en code.",id:"transcription-des-r\xe8gles-en-code",level:3},{value:"Noeud de parsage <code>ParsedNode</code>",id:"noeud-de-parsage-parsednode",level:3},{value:"Le parser - classe <code>ParserData</code>",id:"le-parser---classe-parserdata",level:3},{value:"Le parser - classe <code>Parser</code>",id:"le-parser---classe-parser",level:3},{value:"Principe de parsage",id:"principe-de-parsage",level:3}],d={toc:p};function u(e){let{components:n,...i}=e;return(0,t.kt)("wrapper",(0,r.Z)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h2",{id:"analyse-de-la-grammaire-et-g\xe9n\xe9ration-du-code"},"Analyse de la grammaire et g\xe9n\xe9ration du code"),(0,t.kt)("h3",{id:"la-classe-rulesparser"},"La classe ",(0,t.kt)("inlineCode",{parentName:"h3"},"RulesParser")),(0,t.kt)("p",null,"En plus des classiques membres ou fonctions n\xe9cessaires pour parser : ",(0,t.kt)("inlineCode",{parentName:"p"},"at"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"ch"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"next()"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"isWS()"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"ws()")," la classe ",(0,t.kt)("inlineCode",{parentName:"p"},"RulesParser"),"\ndispose des membres :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"std::map<std::string, Rule> rules_names_map;\nstd::vector<Rule> rules_vect;\n")),(0,t.kt)("p",null,"Prenons pour exemple la grammaire suivante :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-text"}," operande: one of\n            a b\n\n   operator: one of\n           + *\n\n   exp:\n     operande\n     operande operator operande\n     exp operator ( exp )\n     exp operator exp\n\n")),(0,t.kt)("p",null,"Une fois la grammaire pars\xe9e par :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"RulesParser parser(test_grammar);\nparser.parse();\n")),(0,t.kt)("p",null,"Le parser maintiendra en m\xe9moire une organisation d\xe9crite par le sch\xe9ma suivant :"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"r\xe9sultat parsage",src:a(1470).Z,width:"699",height:"598"})),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"parser.getAllRules()")," retourne une r\xe9f\xe9rence vers le vecteur ",(0,t.kt)("inlineCode",{parentName:"p"},"rules_vect")," qui contient chacune des r\xe8gles de la grammaire traduites en un type ",(0,t.kt)("inlineCode",{parentName:"p"},"Rule"),"."),(0,t.kt)("p",null,"A ce stade du d\xe9veloppement les r\xe8gles sont partag\xe9es en deux cat\xe9gories :"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Les r\xe8gles qui v\xe9rifient ",(0,t.kt)("inlineCode",{parentName:"li"},"Rule.isOneOf() === true")," (on les dira de type ",(0,t.kt)("em",{parentName:"li"},"isOneOf"),") : ",(0,t.kt)("br",null),"Elles d\xe9finissent des 'mots' r\xe9serv\xe9s, des keywords, des caract\xe8res particuliers... Une telle\nr\xe8gle \xe9tant v\xe9rifi\xe9e quand l'un des 'mots' ou 'caract\xe8res' (qu'on appellera des ",(0,t.kt)("inlineCode",{parentName:"li"},"specials"),") est pr\xe9sent \xe0 l'emplacement du caract\xe8re courant de parsage."),(0,t.kt)("li",{parentName:"ul"},"Les r\xe8gles qui v\xe9rifient ",(0,t.kt)("inlineCode",{parentName:"li"},"Rule.isOneOf() === false")," : ",(0,t.kt)("br",null),"Elles sont d\xe9finies par plusieurs lignes de r\xe8gles. Chaque ligne est de type ",(0,t.kt)("inlineCode",{parentName:"li"},"RuleLine")," qui contient un vector ",(0,t.kt)("inlineCode",{parentName:"li"},"items"),"\nde ",(0,t.kt)("inlineCode",{parentName:"li"},"strings")," o\xf9 chaque item peut \xeatre ou le nom d'une r\xe8gle d\xe9j\xe0 d\xe9finie (et tr\xe8s souvent pour r\xe9cursion le nom de la r\xe8gle courante elle m\xeame) ou dans le cas contraire ce sera un ",(0,t.kt)("inlineCode",{parentName:"li"},"special")," :\nun mot r\xe9serv\xe9, une parenth\xe8se, un crochet, un caract\xe8re particulier...etc. Chaque ",(0,t.kt)("inlineCode",{parentName:"li"},"RuleLine")," est un \xe9l\xe9ment du vector ",(0,t.kt)("inlineCode",{parentName:"li"},"rules")," membre de la r\xe8gle.")),(0,t.kt)("h2",{id:"le-code-g\xe9n\xe9r\xe9-et-son-utilisation"},"Le code g\xe9n\xe9r\xe9 et son utilisation."),(0,t.kt)("h3",{id:"transcription-des-r\xe8gles-en-code"},"Transcription des r\xe8gles en code."),(0,t.kt)("admonition",{type:"note"},(0,t.kt)("p",{parentName:"admonition"},"Le code indiqu\xe9 ci-dessous est le ",(0,t.kt)("strong",{parentName:"p"},"code g\xe9n\xe9r\xe9")," par le parser de grammaire. La classe ",(0,t.kt)("inlineCode",{parentName:"p"},"Parser")," ci-dessous n'intervient pas dans la phase d'analyse des r\xe8gles et de g\xe9n\xe9ration du code (c'est le r\xf4le de ",(0,t.kt)("inlineCode",{parentName:"p"},"RulesParser"),"), mais\ndans la phase d'utilisation du code g\xe9n\xe9r\xe9 puis compil\xe9 pour tester la validit\xe9 d'expressions.")),(0,t.kt)("p",null,"Chaque r\xe8gle est traduite en code par une m\xe9thode de la classe ",(0,t.kt)("inlineCode",{parentName:"p"},"Parser")," dont le nom commence par ",(0,t.kt)("inlineCode",{parentName:"p"},"rl_")," suivi du nom de la r\xe8gle.",(0,t.kt)("br",null),"\nAinsi la r\xe8gle ",(0,t.kt)("inlineCode",{parentName:"p"},"operande")," sera traduite par la r\xe8gle : ",(0,t.kt)("inlineCode",{parentName:"p"},"ParsedNode Parser::rl_operande()"),".",(0,t.kt)("br",null),"\nUne expression (de type ",(0,t.kt)("inlineCode",{parentName:"p"},"std::string"),") sera ainsi globalement test\xe9e pour notre grammaire par la fonction ",(0,t.kt)("inlineCode",{parentName:"p"},"Parser::rl_exp()")," qui retourne un ",(0,t.kt)("inlineCode",{parentName:"p"},"ParsedNode"),"."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'std::string toParse{"a+b*a*(b+a)*c"}\nParser parser(toParse);\nParsedNode node = parser.rl_exp();\ncout << toparse << ": " << std::boolalpha << node.ok << (node.ok ? ": " + node.value : ": syntax error");\ncout << endl;\n')),(0,t.kt)("p",null,"L'ex\xe9cution du code pr\xe9c\xe9dent donnera :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-javascript"},"a+b*a*(b+a)*c: true: a+b*a*(b+a)\n")),(0,t.kt)("h3",{id:"noeud-de-parsage-parsednode"},"Noeud de parsage ",(0,t.kt)("inlineCode",{parentName:"h3"},"ParsedNode")),(0,t.kt)("p",null,"Un noeud de parsage ",(0,t.kt)("inlineCode",{parentName:"p"},"ParsedNode")," retourn\xe9 par les fonctions de parsage ",(0,t.kt)("inlineCode",{parentName:"p"},"rl_....")," est d\xe9fini ainsi :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"class ParsedNode {\npublic:\n  ParsedNode(ParserData& parser, std::string kind);\n  bool ok;\n  std::string value;\n  size_t begin;\n  size_t end;\n  std::string kind;\n  prs_error error;\n  ParserData& parser;\n  bool exit;\n  std::vector<ParsedNode> children;\n  ParsedNode& close(bool ok, bool exit=false);\n};\n")),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"ok")," \xe0 ",(0,t.kt)("inlineCode",{parentName:"li"},"true")," indique que la fonction de parsage a correctement pars\xe9 autrement dit qu'elle a pu progresser d'un certain nombre (non nul)\nde caract\xe8res qui respectent la r\xe8gle qu'elle repr\xe9sente.",(0,t.kt)("br",null),(0,t.kt)("inlineCode",{parentName:"li"},"ok")," \xe0 ",(0,t.kt)("inlineCode",{parentName:"li"},"false")," indique donc que le parsage n'a pas du tout pu progresser."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"value")," : la cha\xeene qui a pu \xeatre correctement pars\xe9e."),(0,t.kt)("li",{parentName:"ul"},"begin: la position du caract\xe8re courant \xe0 l'entr\xe9e dans la fonction de parsage."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"end")," : la position du caract\xe8re courant \xe0 la sortie de la fonction de parsage.",(0,t.kt)("br",null),"\xa0","\xa0","\xa0","\xa0",'Si value = "Vincent" .... 51 52 ',"[V 53][i 54]"," .......","[t 59]"," 60 61 ... alors ",(0,t.kt)("inlineCode",{parentName:"li"},"begin")," = 53 et ",(0,t.kt)("inlineCode",{parentName:"li"},"end")," = 60."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"kind")," : le nom de la r\xe8gle de grammaire utilis\xe9e (i.e. le nom de la r\xe8gle sans ",(0,t.kt)("inlineCode",{parentName:"li"},"rl_"),")."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"error"),": repr\xe9sente l'erreur lorsque ",(0,t.kt)("inlineCode",{parentName:"li"},"ok")," == ",(0,t.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"parser")," : une r\xe9f\xe9rence vers le parser."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"exit")," : indique s'il doit y avoir interruption ou non lorsque ",(0,t.kt)("inlineCode",{parentName:"li"},"ok")," == ",(0,t.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"children")," : les noeuds r\xe9sultats des lignes de r\xe8gles qui d\xe9finissent la fonction de parsage courante."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"close()")," est une m\xe9thode qui intervient en fin de parsage de la r\xe8gle. (explications plus loin)")),(0,t.kt)("p",null,"L'\xe9tat de la m\xe9moire apr\xe8s avoir effectu\xe9 le code suivant :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'std::string toParse{"a+b-c"}\nParser parser(toParse);\nParsedNode node = parser.rl_exp();\n')),(0,t.kt)("p",null,"est :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-javascript"},'    Variables locales\n        node    @0x7fffffffe320 ParsedNode\n            begin   0   size_t\n            children    <3 \xe9l\xe9ments>    std::vector<ParsedNode, std::allocator<ParsedNode> >\n                [0] @0x555555579540 ParsedNode\n                    begin   0   size_t\n                    children    <0 \xe9l\xe9ment> std::vector<ParsedNode, std::allocator<ParsedNode> >\n                    end 1   size_t\n                    error   @0x555555579598 prs_error\n                    exit    false   bool\n                    kind    "operande"  std::string\n                    ok  true    bool\n                    parser  @0x5555555795b8 ParserData &\n                    value   "a" std::string\n                [1] @0x5555555795e0 ParsedNode\n                    begin   1   size_t\n                    children    <0 \xe9l\xe9ment> std::vector<ParsedNode, std::allocator<ParsedNode> >\n                    end 2   size_t\n                    error   @0x555555579638 prs_error\n                    exit    false   bool\n                    kind    "operator"  std::string\n                    ok  true    bool\n                    parser  @0x555555579658 ParserData &\n                    value   "+" std::string\n                [2] @0x555555579680 ParsedNode\n                    begin   2   size_t\n                    children    <0 \xe9l\xe9ment> std::vector<ParsedNode, std::allocator<ParsedNode> >\n                    end 3   size_t\n                    error   @0x5555555796d8 prs_error\n                    exit    false   bool\n                    kind    "operande"  std::string\n                    ok  true    bool\n                    parser  @0x5555555796f8 ParserData &\n                    value   "b" std::string\n            end 3   size_t\n            error   @0x7fffffffe378 prs_error\n            exit    false   bool\n            kind    "exp"   std::string\n            ok  true    bool\n            parser  @0x7fffffffe2d0 ParserData &\n            value   "a+b"   std::string\n        parser  @0x7fffffffe2d0 Parser\n            [ParserData]    @0x7fffffffe2d0 ParserData\n        toparse "a+b-c" std::string\n')),(0,t.kt)("h3",{id:"le-parser---classe-parserdata"},"Le parser - classe ",(0,t.kt)("inlineCode",{parentName:"h3"},"ParserData")),(0,t.kt)("p",null,"Le parser d\xe9rive de la classe ",(0,t.kt)("inlineCode",{parentName:"p"},"ParserData"),"."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"struct ParserData {\n  ParserData(std::string s) : unit{s}, at{0}, ch{1} {}\n  std::string unit;\n  size_t at;\n  char ch;\n  Ns::Array_stack<size_t> ats_stack;\n  char next();\n  bool isWS(char c);\n  void ws();\n  void save();\n  void restore();\n  void unsave();\n  bool isThere(std::string word);\n};\n")),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"unit")," : l'unit\xe9 \xe0 parser"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"at")," : la position du caract\xe8re qui suit le caract\xe8re courant"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"ch")," : le caract\xe8re courant (une position avant ",(0,t.kt)("inlineCode",{parentName:"li"},"at"),") initialis\xe9 \xe0 une valeur quelconque diff\xe9rente de ",(0,t.kt)("inlineCode",{parentName:"li"},"'\\0'")," (=",(0,t.kt)("inlineCode",{parentName:"li"},"0"),")"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"ats_stack")," : la pile des positions de ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," \xe0 l'entr\xe9e dans une fonction de parsage."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"next()")," : incr\xe9mente ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," d'une unit\xe9 et retourne le caract\xe8re suivant le caract\xe8re courant actuel qui devient le nouveau caract\xe8re courant.",(0,t.kt)("br",null),"\nSans effet si ",(0,t.kt)("inlineCode",{parentName:"li"},"ch")," est le caract\xe8re de fin de cha\xeene (0)"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"isWS(c"),") : retourne true si ",(0,t.kt)("inlineCode",{parentName:"li"},"c")," est un whitespace ",(0,t.kt)("inlineCode",{parentName:"li"},"' '"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"'\\t'"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"'\\n'"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"'\\r'"),"."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"ws()")," : avance le caract\xe8re courant jusqu'au prochain caract\xe8re qui n'est pas un whitespace.",(0,t.kt)("br",null),"Sans aucun effet si le caract\xe8re courant n'est pas\nlui-m\xeame un whitespace ou si on est en fin de cha\xeene \xe0 parser (",(0,t.kt)("inlineCode",{parentName:"li"},"ch")," = ",(0,t.kt)("inlineCode",{parentName:"li"},"0"),")"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"save()")," : sauvegarde la position de ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," sur la pile des positions"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"restore()")," : r\xe9cup\xe8re la derni\xe8re position de ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," sur la pile et ajuste ",(0,t.kt)("inlineCode",{parentName:"li"},"ch")," en fonction"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"unsave()")," : efface la derni\xe8re position de ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," sauvegard\xe9e sur la pile sans affecter ",(0,t.kt)("inlineCode",{parentName:"li"},"at")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"isThere(word)")," : v\xe9rifie si le mot|caract\xe8re ",(0,t.kt)("em",{parentName:"li"},"word")," est pr\xe9sent \xe0 la position courante sans modifier ni ",(0,t.kt)("inlineCode",{parentName:"li"},"at")," ni ",(0,t.kt)("inlineCode",{parentName:"li"},"ch"),".",(0,t.kt)("br",null),"La position courante est inchang\xe9e.")),(0,t.kt)("h3",{id:"le-parser---classe-parser"},"Le parser - classe ",(0,t.kt)("inlineCode",{parentName:"h3"},"Parser")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Parser : public ParserData {\n  Parser(std::string unit) : ParserData(unit) { next(); }\n  ParsedNode rl_operande();\n  ParsedNode rl_operator();\n  ParsedNode rl_exp();\n  ParsedNode term_(std::string term);\n  bool applyRule(ParsedNode& parent, ParsedNode(Parser::*rule)());\n  bool applyRule(ParsedNode& parent, std::string term);\n};\n")),(0,t.kt)("p",null,"Le parser contient les trois fonctions de parsage g\xe9n\xe9r\xe9es par ",(0,t.kt)("inlineCode",{parentName:"p"},"RulesParser"),"."),(0,t.kt)("h3",{id:"principe-de-parsage"},"Principe de parsage"),(0,t.kt)("p",null,"Chaque r\xe8gle v\xe9rifi\xe9e retourne un noeud de parsage avec ",(0,t.kt)("inlineCode",{parentName:"p"},"ok")," = ",(0,t.kt)("inlineCode",{parentName:"p"},"true")),(0,t.kt)("p",null,"Pour parser la r\xe8gle exp :"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-text"},"  exp:\n     operande\n     operande operator operande\n     exp operator ( exp )\n     exp operator exp\n\n")),(0,t.kt)("admonition",{type:"caution"},(0,t.kt)("p",{parentName:"admonition"},"Les lignes (",(0,t.kt)("inlineCode",{parentName:"p"},"RuleLine"),"s 3 et 4, commencent toutes deux par la r\xe8gle ",(0,t.kt)("inlineCode",{parentName:"p"},"exp")," qui est la r\xe8gle en cours de test : on dira qu'elles sont r\xe9cursives\nsur la gauche. Dans ce cas, pour ne pas cr\xe9er une boucle infini, on proc\xe8dera ainsi :"),(0,t.kt)("ul",{parentName:"admonition"},(0,t.kt)("li",{parentName:"ul"},"Si l'une des lignes pr\xe9c\xe9dentes n'est pas valid\xe9e, alors ",(0,t.kt)("inlineCode",{parentName:"li"},"exp")," ne peut pas \xeatre valid\xe9e est on marquera le noeud retourn\xe9 avec ",(0,t.kt)("inlineCode",{parentName:"li"},"ok")," = false."),(0,t.kt)("li",{parentName:"ul"},"Sinon c'est que ",(0,t.kt)("inlineCode",{parentName:"li"},"exp")," est v\xe9rifi\xe9e et on passera sa v\xe9rification en commen\xe7ant la v\xe9rification \xe0 l'item suivant ",(0,t.kt)("inlineCode",{parentName:"li"},"operator")," apr\xe8s avoir ajust\xe9 ",(0,t.kt)("inlineCode",{parentName:"li"},"ch")," et ",(0,t.kt)("inlineCode",{parentName:"li"},"at"),"\nen cons\xe9quence."))),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"Il y a quatre ",(0,t.kt)("inlineCode",{parentName:"p"},"RuleLine"),"s qu'il faut parser dans l'ordre et retenir le dernier noeud valide retourn\xe9 par chacune d'elle.\nOn pr\xe9pare pour cela un tableau ",(0,t.kt)("inlineCode",{parentName:"p"},"parents")," de quatre noeuds initialis\xe9s avec ",(0,t.kt)("inlineCode",{parentName:"p"},"kind"),' = "exp" et ',(0,t.kt)("inlineCode",{parentName:"p"},"begin")," = position du caract\xe8re courant et\nun pointeur ",(0,t.kt)("inlineCode",{parentName:"p"},"good_node")," qui pointera progressivement vers le dernier noeud valide.")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"Pour chaque ligne :"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"on initialise un tableau correspondant aux items de la ligne o\xf9 pour chaque item qui est une r\xe8gle on lui fait correspondre\nun pointeur vers cette r\xe8gle et si l'item est un ",(0,t.kt)("inlineCode",{parentName:"p"},"special")," (i.e. un ",(0,t.kt)("inlineCode",{parentName:"p"},"terminal"),") on lui fera correspondre ",(0,t.kt)("inlineCode",{parentName:"p"},"nullptr"),". Ce qui donne par exemple\npour la ligne 3 :",(0,t.kt)("br",null)," ",(0,t.kt)("inlineCode",{parentName:"p"},"ParseFunction items_3[5]{&Parser::rl_exp, &Parser::rl_operator, nullptr,&Parser::rl_exp, nullptr}"))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"on parse la ligne en utilisant les fonctions du tableau pr\xe9c\xe9dent qui si elles sont correctement pars\xe9es fourniront un noeux avec ",(0,t.kt)("inlineCode",{parentName:"p"},"ok")," = true\nqui sera ajout\xe9 aux children du parent, ce dernier \xe9tant la r\xe8gle en cours de parsage, autrement dit le noeud parents","[i-1]"," correspondant \xe0 la i-\xe8me ligne en cours de parsage."))))))}u.isMDXComponent=!0},1470:(e,n,a)=>{a.d(n,{Z:()=>r});const r=a.p+"assets/images/pars_result-56a588c35a26acefdaf433e94c7fd929.png"}}]);