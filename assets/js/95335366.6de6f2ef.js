"use strict";(self.webpackChunksvl_doc=self.webpackChunksvl_doc||[]).push([[454],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>k});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,k=u["".concat(s,".").concat(m)]||u[m]||c[m]||l;return t?a.createElement(k,r(r({ref:n},d),{},{components:t})):a.createElement(k,r({ref:n},d))}));function k(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,r=new Array(l);r[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[u]="string"==typeof e?e:o,r[1]=i;for(var p=2;p<l;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2881:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294);function o(){return a.createElement("span",{style:{position:"relative",bottom:"0.3rem",background:"#d8f7df",border:"solid 1px #b8d7bf",borderRadius:"0.2rem",color:"#666",padding:"0.15rem 0.35rem",marginLeft:"0.5rem",fontSize:"0.9rem",fontWeight:"400"}},"dev")}},8630:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=t(7462),o=(t(7294),t(3905)),l=t(2881);const r={description:"Signaux & Slots",title:"Signaux & Slots",sidebar_position:2,keywords:["signal","slot","signaux","slots"],sidebar_label:"Signaux & Slots",sidebar_class_name:"dev-icon"},i="Signaux & slots <Dev/>",s={unversionedId:"signaux&slots/Signaux&Slots",id:"signaux&slots/Signaux&Slots",title:"Signaux & Slots",description:"Signaux & Slots",source:"@site/docs/signaux&slots/Signaux&Slots.mdx",sourceDirName:"signaux&slots",slug:"/signaux&slots/",permalink:"/svl-doc/docs/signaux&slots/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"Signaux & Slots",title:"Signaux & Slots",sidebar_position:2,keywords:["signal","slot","signaux","slots"],sidebar_label:"Signaux & Slots",sidebar_class_name:"dev-icon"},sidebar:"tutorialSidebar",previous:{title:"Signal",permalink:"/svl-doc/docs/signaux&slots/Signaux"},next:{title:"liteJSON",permalink:"/svl-doc/docs/category/litejson"}},p={},d=[{value:"Quel type pour repr\xe9senter un slot ?",id:"quel-type-pour-repr\xe9senter-un-slot-",level:2},{value:"Anonymiser l&#39;objet \xe0 connecter",id:"anonymiser-lobjet-\xe0-connecter",level:2},{value:"Anonymiser la m\xe9thode \xe0 connecter",id:"anonymiser-la-m\xe9thode-\xe0-connecter",level:2},{value:"R\xf4le de la classe <code>SlotKey</code>",id:"r\xf4le-de-la-classe-slotkey",level:2},{value:"Construction des slots",id:"construction-des-slots",level:2},{value:"Ex\xe9cution des slots",id:"ex\xe9cution-des-slots",level:2},{value:"\u0421onnexion d&#39;un signal \xe0 une m\xe9thode",id:"\u0441onnexion-dun-signal-\xe0-une-m\xe9thode",level:2},{value:"D\xe9connexion d&#39;un signal",id:"d\xe9connexion-dun-signal",level:2}],u={toc:d};function c(e){let{components:n,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"signaux--slots-"},"Signaux & slots ",(0,o.kt)(l.Z,{mdxType:"Dev"})),(0,o.kt)("p",null,"#include ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/sviosdi/signals_slots/-/blob/main/include/Signal.hpp"},'"Signal.hpp"'),(0,o.kt)("br",null),"\n#include ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/sviosdi/signals_slots/-/blob/main/include/Slot.hpp"},'"Slot.hpp"')),(0,o.kt)("h2",{id:"quel-type-pour-repr\xe9senter-un-slot-"},"Quel type pour repr\xe9senter un slot ?"),(0,o.kt)("p",null,"Les classes ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," et ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," sont des patrons de classe dont les param\xe8tres sont une liste variable correspondant aux param\xe8tres du signal.\nLa classe Signal d\xe9rive de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal")," qui n'est pas un patron de classe. (On expliquera pourquoi plus loin.)"),(0,o.kt)("p",null,"Chaque signal contient un conteneur (\xe0 d\xe9terminer) ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots")," des slots de type ",(0,o.kt)("inlineCode",{parentName:"p"},"<Slot<Params...>")," qui lui sont connect\xe9s. A l'\xe9mission du signal par l'op\xe9rateur\n",(0,o.kt)("inlineCode",{parentName:"p"},"Signal::operator()(Params...)"),", tous les slots du conteneur ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots")," sont ex\xe9cut\xe9s par l'op\xe9rateur : ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot::operator()(Params...)"),"."),(0,o.kt)("p",null,"Seuls les param\xe8tres d'un signal donn\xe9 d\xe9terminent les fonctions ou m\xe9thodes auxquelles il peut \xeatre connect\xe9. Le conteneur ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots")," aura donc pour contrainte de\ndevoir stocker des objets qui repr\xe9sentent les slots de type ",(0,o.kt)("inlineCode",{parentName:"p"},"<Slot<Params...>"),". Or ceux-ci, m\xeame s'ils ont en commun le type de leur param\xe8tres, peuvent \xeatre tr\xe8s diff\xe9rents par le\nfait qu'ils soient des fonctions ou des m\xe9thodes, et s'ils sont des m\xe9thodes d'un objet, cet objet peut \xeatre l'instance de classes diff\xe9rentes. Le type des valeurs de\nretour peuvent aussi diff\xe9rer."),(0,o.kt)("p",null,"Notre type ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot<Params...>")," doit pouvoir repr\xe9senter ces slots finalement tr\xe8s diff\xe9rents, qui n'ont que le type de leurs param\xe8tres en commun, conforme \xe0 ceux du\nsignal. Pour rendre ceci possible, un slot doit donc perdre lors de sa cr\xe9ation le fait d'\xeatre une fonction ou une m\xe9thode. Il doit aussi oublier la signature de\nla fonction ou de la m\xe9thode, le type de la valeur de retour et oublier le type de l'objet connect\xe9. Mais il faudra pouvoir retrouver toutes ses caract\xe9ristiques\nde type ",(0,o.kt)("em",{parentName:"p"},"[fonction | m\xe9thode]","/signature/objet connect\xe9")," lors de l'ex\xe9cution du slot."),(0,o.kt)("h2",{id:"anonymiser-lobjet-\xe0-connecter"},"Anonymiser l'objet \xe0 connecter"),(0,o.kt)("p",null,"La classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," dispose d'un constructeur de ",(0,o.kt)("em",{parentName:"p"},"slot pour m\xe9thode")," ou d'un constructeur de ",(0,o.kt)("em",{parentName:"p"},"slot pour fonction"),". Leur r\xf4le \xe9tant d'enregistrer les pointeurs vers\nl'",(0,o.kt)("em",{parentName:"p"},"objet&m\xe9thode")," ou vers la ",(0,o.kt)("em",{parentName:"p"},"fonction")," de mani\xe8re ",(0,o.kt)("em",{parentName:"p"},"anonymis\xe9e")," (anonymiser = rendre anonyme de mani\xe8re r\xe9versible), en leur faisant perdre leur type pour devenir\ndes pointeurs ",(0,o.kt)("inlineCode",{parentName:"p"},"void*")," ou ",(0,o.kt)("inlineCode",{parentName:"p"},"char*"),". Dans le cas d'un ",(0,o.kt)("em",{parentName:"p"},"slot m\xe9thode"),", on pourrait enregister de mani\xe8re anonymis\xe9 l'objet connect\xe9 en enregistrant son adresse convertie\nen ",(0,o.kt)("inlineCode",{parentName:"p"},"void*")," dans un membre ",(0,o.kt)("inlineCode",{parentName:"p"},"obj_anonyme"),". (qui prendrait la valeur ",(0,o.kt)("inlineCode",{parentName:"p"},"nullptr")," dans le cas d'un ",(0,o.kt)("em",{parentName:"p"},"slot fonction"),".)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void* obj_anonyme{reinterpret_cast<void*>(obj_appele)};             // anonymisation\nOBJ_APPELE* ptr_obj{reinterpret_cast<OBJ_APPELE*>(obj_anonyme)};    // d\xe9sanonymisation\n(*ptr_obj).methode()    // ok - m\xe9thode utilisable  ptr_obj == obj_appele\nptr_obj->methode()      // ok\n")),(0,o.kt)("h2",{id:"anonymiser-la-m\xe9thode-\xe0-connecter"},"Anonymiser la m\xe9thode \xe0 connecter"),(0,o.kt)("p",null,"Pour ce qui est d'enregistrer une fonction | m\xe9thode, c'est moins simple. Pour bien comprendre ce qu'il va falloir faire, observons l'exemple suivant d'une classe ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," disposant\nd'une m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"p"},"A::meth(int)"),". Le code suivant fonctionne alors correctement :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'A a;\n// PM = type "pointeur vers une m\xe9thode de A" (retournant void et de param\xe8tre int).\nusing PM = void(A::*)(int);\n// la variable m contient l\'adresse de la m\xe9thode meth,\n// pm est un pointeur vers A::meth(int)\nPM pm = &A::meth;\n// appel de la m\xe9thode en d\xe9r\xe9f\xe9ren\xe7ant le pointeur de m\xe9thode.\n(a.*pm)(7);\n')),(0,o.kt)("p",null,"On pourrait \xeatre tent\xe9, comme pour l'objet, de convertir le pointeur de m\xe9thode en void","*"," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void* m_an = reinterpret_cast<void*>(pm) //Non!\n     // conversion d'un pointeur de fonction en void* non autoris\xe9e en C++\n")),(0,o.kt)("p",null,"Mais C++ n'autorise pas la conversion d'un pointeur de fonction en pointeur de void. Il va falloir donc passer par un pointeur vers le pointeur de m\xe9thode :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"showLineNumbers",showLineNumbers:!0},"void* m_an = reinterpret_cast<void*>(&pm);\nPM pm = *reinterpret_cast<PM*>(m_an);    // using PM = void(A::*)(int);\n(a.*pm)(12);\n")),(0,o.kt)("p",null,"On obtient donc l'encha\xeenement suivant de d\xe9r\xe9f\xe9rencements de pointeurs: ",(0,o.kt)("inlineCode",{parentName:"p"},"m_an \u2192 m \u2192 A::meth"),"."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"m_an"),' devient un pointeur "anonymis\xe9" vers le pointeur ',(0,o.kt)("inlineCode",{parentName:"p"},"pm"),". Il pointe vers la zone m\xe9moire contenant ",(0,o.kt)("inlineCode",{parentName:"p"},"pm")," qui pointe \xe0 son tour vers la m\xe9thode. Mais ",(0,o.kt)("inlineCode",{parentName:"p"},"pm")," est\ninterpr\xe9t\xe9 en pointeur de void et non plus en pointeur de m\xe9thode.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"ici on d\xe9sanonymise le pointeur vers pm. Il n'est plus un pointeur vers void mais un pointeur de PM autrement dit un pointeur vers un pointeur de m\xe9thode.\nUne fois d\xe9r\xe9f\xe9renc\xe9, pm devient bien un pointeur de m\xe9thode.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"appel de la m\xe9thode, apr\xe8s d\xe9r\xe9f\xe9rencement du pointeur de m\xe9thode."))),(0,o.kt)("p",null,"\xc9tudions le cas du constructeur d'un ",(0,o.kt)("em",{parentName:"p"},"slot Methode"),". On notera ",(0,o.kt)("inlineCode",{parentName:"p"},"RT")," le type de la valeur retourn\xe9e, ",(0,o.kt)("inlineCode",{parentName:"p"},"OBJ_APPELE")," le type de l'objet connect\xe9e et ",(0,o.kt)("inlineCode",{parentName:"p"},"PARAMS..."),"\nrepr\xe9sente le type des param\xe8tres. Il faut passer comme param\xe8tres du constructeur un pointeur vers l'objet connect\xe9 et un pointeur vers la m\xe9thode de cet objet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"OBJ_APPELE* obj_appele;\nRT(OBJ_APPELE::*methode)(Params...);\n")),(0,o.kt)("p",null,"On a vu pr\xe9c\xe9demment que l'anonymisation du pointeur de l'objet appel\xe9 dans le membre ",(0,o.kt)("inlineCode",{parentName:"p"},"obj_anonyme")," se fait par \xe0 l'initialisation par :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"obj_anonyme{reinterpret_cast<void*>(obj_appele)}\n")),(0,o.kt)("p",null,"Maintenant en prenant un pointeur vers le pointeur de m\xe9thode, on devrait pouvoir \xeatre tent\xe9 \xe0 nouveau de le convertir en ",(0,o.kt)("inlineCode",{parentName:"p"},"void*")," par :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void* ptr_methode;\nptr_methode{reinterpret_cast<void*>(&pm)};\n")),(0,o.kt)("p",null,"o\xf9 ",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode")," serait un membre de Slot de type ",(0,o.kt)("inlineCode",{parentName:"p"},"void*"),".\nEt effectivement on pourrait dans le constructeur d\xe9sanonymiser la m\xe9thode et effectuer (dans le cas o\xf9 par exemple la m\xe9thode a pour param\xe8tre un ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),")\nson appel par le code suivant :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"using PM = RT(OBJ_APPELE::*)(Params...);\nPM pm = *reinterpret_cast<PM*>(ptr_methode);\n(reinterpret_cast<OBJ_APPELE*>(obj_anonyme)->*pm)(84); // OK seulement dans le constructeur\n")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Et pourtant ce code qui devrait s'ex\xe9cuter dans un constructeur de ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," ne marcherait pas en dehors du constructeur. Mais pourquoi donc ?")),(0,o.kt)("p",null,"Car l'enregistrement par : ",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode{reinterpret_cast<void*>(&pm)}")," n'est pas correct. On a en effet cet encha\xeenement de pointeurs:\n",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode \u2192 pm \u2192 OBJ_APPELE::methode"),(0,o.kt)("br",null)),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"pb de variable locale",src:t(6147).Z,width:"663",height:"314"})),(0,o.kt)("p",null,"Si \xe0 ce stade l'emplacement m\xe9moire occup\xe9 par ",(0,o.kt)("inlineCode",{parentName:"p"},"pm")," pointe correctement vers la m\xe9thode de l'objet, cet emplacement m\xe9moire n'est qu'une ",(0,o.kt)("strong",{parentName:"p"},"variable locale"),"\npass\xe9e en param\xe8tre au constructeur. Et par cons\xe9quent \xe0 la sortie du constructeur, le contenu de cet emplacement est perdu, or c'est vers lui que pointe\n",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode"),", qui devient un pointeur vers une zone qui ne contient plus le pointeur vers la m\xe9thode de l'objet!",(0,o.kt)("br",null)," La solution est donc d'allouer un\nespace m\xe9moire ",(0,o.kt)("inlineCode",{parentName:"p"},"char*")," pour ",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode")," et d'y recopier octet par octet le contenu de l'emplacement m\xe9moire occup\xe9 par la variable ",(0,o.kt)("inlineCode",{parentName:"p"},"pm"),".",(0,o.kt)("br",null)),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"L'espace \xe0 allouer \xe0 ",(0,o.kt)("inlineCode",{parentName:"p"},"ptr_methode")," est ",(0,o.kt)("inlineCode",{parentName:"p"},"sizeof(PM)"),", autrement dit la taille d'un pointeur de m\xe9thode. On supposera que cette taille est fixe, ind\xe9pendante de\nla classe ou encore de la signature de la m\xe9thode."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"constexpr short  PTR_METH_SIZE = 16;\n")),(0,o.kt)("p",{parentName:"admonition"},"Avant d'utiliser la classe Signal, il est n\xe9cessaire d'effecter les tests sur la plateforme cible et d'ajuster cette valeur si n\xe9cessaire.")),(0,o.kt)("h2",{id:"r\xf4le-de-la-classe-slotkey"},"R\xf4le de la classe ",(0,o.kt)("inlineCode",{parentName:"h2"},"SlotKey")),(0,o.kt)("p",null,"Revenons \xe0 la classe Signal. Pour synth\xe9tiser, on sait que chaque signal contient un conteneur ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots")," des Slots qui lui sont connect\xe9s et que l'ex\xe9cution\ndu signal aura pour effect d'appeler et d'ex\xe9cuter chacun des slots connect\xe9s. Lors de la connexion d'un slot il faut ajouter le slot au conteneur\nde slots mais il faudra aussi v\xe9rifier que le slot n'est pas d\xe9j\xe0 connect\xe9 (d\xe9j\xe0 existant dans ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots"),") sans quoi le slot risque de s'ex\xe9cuter plusieurs\nfois \xe0 l'\xe9mission du signal. Il faudra aussi pouvoir retrouver rapidement un slot dans le conteneur pour le retirer lors d'une d\xe9connexion. On voit appara\xeetre ici\nla n\xe9cessit\xe9 de pouvoir ",(0,o.kt)("em",{parentName:"p"},"comparer")," des slots, au moins en \xe9galit\xe9. Si on peut en plus leur associer une relation d'ordre on pourra alors plus rapidement acc\xe9der \xe0 un slot.\nAvec une relation d'ordre appropri\xe9e sur les slots on pourra utiliser un ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," qui associera une fonction/m\xe9thode connect\xe9e au Slot qui lui correspond. C'est l\xe0 qu'intervient\nla classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKey"),". Tout commence au niveau de la connexion :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"la fonction | objet&m\xe9thode pass\xe9s lors de la connexion serviront \xe0 construire le ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKey")," correspondant dont le r\xf4le sera de les enregistrer en les anonymisant."),(0,o.kt)("li",{parentName:"ul"},"Ce ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKey")," ainsi cr\xe9\xe9 servira de cl\xe9 dans le ",(0,o.kt)("inlineCode",{parentName:"li"},"map")," avec pour valeur associ\xe9e un ",(0,o.kt)("inlineCode",{parentName:"li"},"Slot")," dont le r\xf4le sera de pouvoir d\xe9sanonymiser le slot et de pouvoir effectuer son appel.")),(0,o.kt)("p",null,"La classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKey")," contient les membres:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void* obj_anonyme;\nunion {\n  char* ptr_methode{nullptr};\n  const void* ptr_function;\n};\n")),(0,o.kt)("p",null,"Et en plus du constructeur par d\xe9faut qui initialise ces membres \xe0 ",(0,o.kt)("inlineCode",{parentName:"p"},"nullptr"),", il y a deux constructeurs selon qu'on connecte une fonction ou une m\xe9thode:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"SlotKey(void* obj, char* meth) : obj_anonyme{obj} {\n  char* tmp = meth;\n  ptr_methode = new char[PTR_METH_SIZE];\n  for(int i = 0; i < PTR_METH_SIZE; i++)\n    ptr_methode[i] = tmp[i];\n}\n\nSlotKey(void* func) : obj_anonyme{nullptr}, ptr_function{func} {\n}\n")),(0,o.kt)("p",null,"Pour comparer les ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKeys")," on comparera directement les adresses de leurs membres. Si ",(0,o.kt)("inlineCode",{parentName:"p"},"obj_anonyme == nullptr")," il s'agira d'un ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"p"},"fonction"),", sinon c'est un ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"p"},"m\xe9thode"),".\nLa relation d'ordre sera d\xe9finie ainsi:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"S'il s'agit de deux ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"fonction")," : on compare directement leurs adresses."),(0,o.kt)("li",{parentName:"ul"},"S'il s'agit d'un ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"fonction")," et d'un ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"m\xe9thode")," : on consid\xe9ra que ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"fonction")," < ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"m\xe9thode"),"."),(0,o.kt)("li",{parentName:"ul"},"S'il s'agit de deux ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKeys")," ",(0,o.kt)("em",{parentName:"li"},"m\xe9thode")," : il seront dans l'ordre des objets ",(0,o.kt)("inlineCode",{parentName:"li"},"obj_anonyme")," si ceux-ci sont diff\xe9rents, et s'il sont \xe9gaux\nils seront dans l'ordre des m\xe9thodes ",(0,o.kt)("inlineCode",{parentName:"li"},"ptr_methode"),". Mais dans ce dernier cas, on fera attention \xe0 ne pas comparer directement les valeurs de ",(0,o.kt)("inlineCode",{parentName:"li"},"ptr_methode"),", mais les valeurs\nvers lesquelles elles pointent en les d\xe9r\xe9f\xe9ren\xe7ant.")),(0,o.kt)("p",null,"On fournira \xe0 la classe SlotKey un constructeur par copie, un destructeur et fournira les op\xe9rateurs ",(0,o.kt)("inlineCode",{parentName:"p"},"friend")," de comparaison, n\xe9cessaires pour l'utilisation du ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),".\nOn peut maintenant d\xe9finir notre conteneur de slots dans la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::map<SlotKey, Slot<Params...>> connectedSlots;\n")),(0,o.kt)("p",null,"Il reste \xe0 \xe9tudier maintenant comment est construit un slot et comment s'effectue son appel."),(0,o.kt)("h2",{id:"construction-des-slots"},"Construction des slots"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Params>\nclass Slot {\npublic:\n    Slot() {}\n    Slot(void(*fct_appel)(const SlotKey&, Params...)) : appel{fct_appel} {\n    }\n\n    void operator()(const SlotKey& key, Params... params){\n        appel(key, params...);\n    }\n\n    bool operator!=(const Slot& other) {\n        return appel != other.appel;\n    }\n\n    void (*appel)(const SlotKey&, Params...);\n\n};\n")),(0,o.kt)("p",null,"Comme expliqu\xe9 auparavant, le patron de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," ne doit d\xe9pendre que du type des param\xe8tres. Les autres types n\xe9cessaires ",(0,o.kt)("inlineCode",{parentName:"p"},"RT")," et ",(0,o.kt)("inlineCode",{parentName:"p"},"OBJ_APPELE")," ne devant pas\nintervenir dans cette classe. Le constructeur de ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," re\xe7oit en param\xe8tre et l'enregistre un pointeur vers une fonction",(0,o.kt)("inlineCode",{parentName:"p"}," appel(...)")," qui est une fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"static")," d'une sous classe,\ncette derni\xe8re pouvant faire intervenir les autres types. Cette fonction par l'interm\xe9diaire des param\xe8tres qu'elle re\xe7oit \xe0 l'ex\xe9cution du ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," sera capable de\nd\xe9sanonymiser le slot et d'effectuer son appel. Observons le cas d'un ",(0,o.kt)("em",{parentName:"p"},"slot m\xe9thode")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename OBJ_APPELE, typename RT, typename... Params>\nclass SlotMethode : public Slot<Params...> {\npublic:\n    SlotMethode() : Slot<Params...>(&appel) {\n    }\n\n    static void appel(const SlotKey& key, Params... params) {\n        using TYPE_PTR_METHODE = RT(OBJ_APPELE::*)(Params... params);\n        OBJ_APPELE* objet_appele  =   reinterpret_cast<OBJ_APPELE*>(key.obj_anonyme);\n        TYPE_PTR_METHODE methode  = *(reinterpret_cast<TYPE_PTR_METHODE*>(key.ptr_methode));\n        (objet_appele->*methode) (params...);\n    }\n\n};\n")),(0,o.kt)("p",null,"Le constructeur n'a pas de param\xe8tre, mais il passe \xe0 la classe de base ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," le pointeur vers sa fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"static")," ",(0,o.kt)("inlineCode",{parentName:"p"},"appel(..."),"). Lorsque le slot est\nappel\xe9, cette fonction est ex\xe9cut\xe9e, et comme son premier param\xe8tre est un ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKey")," qui comporte en lui toutes les donn\xe9es anonymis\xe9es n\xe9cessaires\npour retrouver le type du slot, il peut le d\xe9sanonymiser puis utiliser les param\xe8tres pass\xe9s par le second param\xe8tre pour effectuer l'appel d\xe9finitif de la m\xe9thode\nd\xe9sanonymis\xe9e sur l'objet d\xe9sanonymis\xe9."),(0,o.kt)("h2",{id:"ex\xe9cution-des-slots"},"Ex\xe9cution des slots"),(0,o.kt)("p",null,"La magie op\xe8re : nos ",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKey"),"s ont tous le m\xeame type, nos ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot"),"s ont tous le m\xeame type, on peut ainsi mapper l'un \xe0 l'autre dans un\n",(0,o.kt)("inlineCode",{parentName:"p"},"std::map<SlotKey, Slot<Params...>>")," et \xe0 l'\xe9mission du signal il suffira de parcourir les valeurs du ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," pour effectuer tous les appels n\xe9cessaires :\nc'est le r\xf4le de l'op\xe9rateur ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," de la classe Signal :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void operator()(Params... params) {\n    for(auto& [key, value] : connectedSlots) {\n        Slot<Params...>& slot = value;\n        slot(key, params...);\n    }\n}\n")),(0,o.kt)("h2",{id:"\u0441onnexion-dun-signal-\xe0-une-m\xe9thode"},"\u0421onnexion d'un signal \xe0 une m\xe9thode"),(0,o.kt)("p",null,"Observons maintenant plus pr\xe9cis\xe9ment le fonctionnement d'une connexion d'un signal \xe0 une m\xe9thode :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"}," template <typename OBJ_APPELE, typename RT>\n  void connect(OBJ_APPELE *obj_appele, RT (OBJ_APPELE::*methode)(Params...)) {\n    SlotKey key(reinterpret_cast<void *>(obj_appele),\n                reinterpret_cast<char *>(&methode));\n    if (connectedSlots.count(key))\n      return;\n    SlotMethode<OBJ_APPELE, RT, Params...> slot;\n    if (std::is_base_of<Object, OBJ_APPELE>::value) {\n      ((Object *)obj_appele)->addSignal(this);\n      slot.isObject = true;\n    }\n    connectedSlots[key] = slot;\n  }\n")),(0,o.kt)("p",null,"Imaginons la connexion d'un objet ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," , instance d'une classe ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," , \xe0 une m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"p"},"A::m(int, const char*)"),".",(0,o.kt)("br",null),"\nLa connexion se fait ainsi : ",(0,o.kt)("inlineCode",{parentName:"p"},"a.connect(&a, &A::m)"),(0,o.kt)("br",null),"\nOn voit appara\xeetre les quatre \xe9tapes suivantes :"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Les types OBJ_APPELE, RT et Params sont d\xe9duits des param\xe8tres pass\xe9s \xe0 la connexion."),(0,o.kt)("li",{parentName:"ol"},"On cr\xe9e un ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKey")," qui va r\xe9cup\xe9rer les donn\xe9es et les anonymiser. S'il est d\xe9j\xe0 pr\xe9sent, c'est que le signal \xe0 d\xe9j\xe0 \xe9t\xe9 connect\xe9\n\xe0 ce slot, on ignore alors la connexion en retournant sans rien faire."),(0,o.kt)("li",{parentName:"ol"},"On construit un ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotMethode")," sans aucun argument : c'est une sorte de coquille vide, mais qui r\xe9cup\xe8re tous les types\n\xe9nonc\xe9s au point 1."),(0,o.kt)("li",{parentName:"ol"},"On teste ensuite si l'objet connect\xe9 est une instance d'une classe d\xe9riv\xe9e de la classe ",(0,o.kt)("inlineCode",{parentName:"li"},"svl::Object")," et si c'est le cas, on ajoute le signal au\nconteneur des signaux de l'objet par la m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"li"},"Object::addSignal()")," ce qui permettra, en cas de destruction de l'objet, de d\xe9connecter ",(0,o.kt)("em",{parentName:"li"},"ce"),"\nsignal et de la m\xeame fa\xe7on ",(0,o.kt)("em",{parentName:"li"},"tous")," les signaux qui lui sont connect\xe9s. On marque ce slot comme \xe9tant un slot m\xe9thode d'un objet d\xe9rivant de la classe\n",(0,o.kt)("inlineCode",{parentName:"li"},"Object"),"."),(0,o.kt)("li",{parentName:"ol"},"On enregistre dans le signal (dans son map ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots"),") la paire ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotKey")," \u279e ",(0,o.kt)("inlineCode",{parentName:"li"},"SlotMethode"),". Et on peut le faire, car un\n",(0,o.kt)("inlineCode",{parentName:"li"},"SlotMethode")," ",(0,o.kt)("strong",{parentName:"li"},"est un")," ",(0,o.kt)("inlineCode",{parentName:"li"},"Slot")," et on n'a pas besoin d'avoir de pointeurs de slots ou de r\xe9f\xe9rences de slots pour faire fonctionner\nle polymorphisme, car la seule m\xe9thode utilis\xe9e dans les slots est l'operateur d'appel ",(0,o.kt)("inlineCode",{parentName:"li"},"()")," qui est une m\xe9thode propre \xe0 la classe de base.")),(0,o.kt)("h2",{id:"d\xe9connexion-dun-signal"},"D\xe9connexion d'un signal"),(0,o.kt)("p",null,"Prenons l'exemple d'une d\xe9connexion d'une m\xe9thode : ",(0,o.kt)("inlineCode",{parentName:"p"},"a->disconnect(&a, &A:m)")," ",(0,o.kt)("br",null),"Pour une fonction c'est tr\xe8s similaire en plus simple."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename OBJ_APPELE, typename RT>\n  void disconnect(OBJ_APPELE *obj_appele,\n                  RT (OBJ_APPELE::*methode)(Params...)) {\n    SlotKey key(reinterpret_cast<void *>(obj_appele),\n                reinterpret_cast<char *>(&methode));\n    if (connectedSlots.count(key))\n      connectedSlots.erase(key);\n    if (std::is_base_of<Object, OBJ_APPELE>::value) {\n      ((Object *)obj_appele)->removeOneSignal(this);\n    }\n  }\n")),(0,o.kt)("p",null,"On reconstruit un SlotKey \xe0 partir des param\xe8tres de d\xe9connexion, puis il ne reste plus qu'\xe0 retirer ce SlotKey du map ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots"),", ce\nqui peut s'ex\xe9cuter tr\xe8s rapidement.",(0,o.kt)("br",null),"\nSi l'object connect\xe9 d\xe9rive de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," on ajoute le signal \xe0 la liste des signaux qui lui sont connnect\xe9s. Et ce une seule fois car le signal\ndoit appara\xeetre dans la liste autant de fois qu'il y a de m\xe9thodes de l'objet connect\xe9es \xe0 ce signal."),(0,o.kt)("p",null,"On notera ici que la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," d\xe9rive de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"L'utilisateur n'a pas \xe0 se soucier de cette classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal"),". Il devra d\xe9clarer simplement tous ses signaux en tant que ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal<type des param\xe8tres...>"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class SaSSignal {\npublic:\n    virtual void disconnect(void* obj_an) = 0;\n\n};\n")),(0,o.kt)("p",null,"Cette classe n'a qu'une m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"p"},"disconnect()")," virtuelle pure ",(0,o.kt)("em",{parentName:"p"},"r\xe9\xe9crite")," (",(0,o.kt)("inlineCode",{parentName:"p"},"override"),") dans la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename OBJ_APPELE> void disconnect(OBJ_APPELE *obj) {\n    typename std::map<SlotKey, Slot<Params...>>::iterator itr =\n        connectedSlots.begin();\n    while (itr != connectedSlots.end()) {\n      if (itr->first.obj_anonyme == obj) {\n        itr = connectedSlots.erase(itr);\n      } else {\n        ++itr;\n      }\n    }\n    if (std::is_base_of<Object, OBJ_APPELE>::value) {\n      ((Object *)obj)->removeAllSignals(this);\n    }\n  }\n")),(0,o.kt)("p",null,"L'utilisateur pourra manuellement utiliser cette fonction sur un signal pour d\xe9connecter ce signal de toutes les m\xe9thodes de l'objet pass\xe9\nen param\xe8tre auxquelles il aurait \xe9t\xe9 connect\xe9 pr\xe9c\xe9demment. Cette fonction parcourt tous les cl\xe9s (",(0,o.kt)("inlineCode",{parentName:"p"},"SlotKey"),"s) du map ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSlots")," et en retire\ntoute cl\xe9 (et par cons\xe9quent le ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," associ\xe9) comprenant un objet \xe9gal \xe0 l'objet que l'on veut d\xe9connecter.",(0,o.kt)("br",null),"\nMais cette fonction a surtout son int\xe9r\xeat lorsqu'elle est appel\xe9e par polymorphisme \xe0 partir de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal"),". Ce qui a lieu automatiquement lorsqu'un objet\nde la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," ayant \xe9t\xe9 connect\xe9 \xe0 un ou plusieurs signaux est d\xe9truit. Et comme on l'a d\xe9j\xe0 fait remarquer, il est imp\xe9ratif de d\xe9connecter\ntous ces signaux, sans quoi, l'\xe9mission de l'un deux ",(0,o.kt)("strong",{parentName:"p"},"apr\xe8s")," la destruction de l'objet conduirait \xe0 un crash ou tout au moins \xe0 un comportement ind\xe9fini.",(0,o.kt)("br",null),"\nEt ceci est fait dans le destructeur de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"Object::~Object() { deleteConnectedSignals(); }\nvoid Object::deleteConnectedSignals() {\n  for (SaSSignal *signal : connectedSignals) {\n    signal->disconnect(this);\n  }\n}\n")),(0,o.kt)("p",null,"o\xf9 ",(0,o.kt)("inlineCode",{parentName:"p"},"connectSignals")," est un vecteur de tous les signaux (",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal"),"s) connect\xe9s \xe0 l'objet, auquel chaque signal a \xe9t\xe9 ajout\xe9, lors de la\nconnexion, par la fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"Object::addSignal()")," comme vu pr\xe9c\xe9demment."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void Object::addSignal(SaSSignal* signal) {\n        connectedSignals.push_back(signal);\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Pour pouvoir utiliser le polymorphisme, on utilise plus pr\xe9cis\xe9ment des pointeurs de signaux ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal*"),"s :"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<SaSSignal*> connectedSignals;\n"))),(0,o.kt)("p",null,"Ce qui assurera dans le destructeur de l'objet, que l'appel ",(0,o.kt)("inlineCode",{parentName:"p"},"signal->disconnect(this);")," se fera sur la m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"p"},"disconnect()")," de ",(0,o.kt)("inlineCode",{parentName:"p"},"Signal")," et\nnon celle de ",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"d\xe9connexions",src:t(1896).Z,width:"691",height:"389"})),(0,o.kt)("p",null,"On veillera \xe0 ce que :"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Un signal ne doit pouvoir \xeatre connect\xe9 qu'une seule fois \xe0 une m\xeame fonction/m\xe9thode. Toute autre connexion redondante doit \xeatre sans effect. Si le signal\nest ex\xe9cut\xe9 une fois, tout slot connect\xe9 ne doit s'ex\xe9cuter qu'une seule fois.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\xc0 la connexion d'un slot : ",(0,o.kt)("inlineCode",{parentName:"p"},"signal.connect(&a, &A::m)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Ne rien faire si le slot est d\xe9j\xe0 pr\xe9sent dans ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots")),(0,o.kt)("li",{parentName:"ul"},"Si le slot se rattache \xe0 un objet d\xe9rivant de la classe ",(0,o.kt)("inlineCode",{parentName:"li"},"Object"),":",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Marquer ce slot avec ",(0,o.kt)("inlineCode",{parentName:"li"},"isObject = true")," ",(0,o.kt)("a",{parentName:"li",href:"#note_1"},"\u2192 voir NOTE 1")),(0,o.kt)("li",{parentName:"ul"},"Ajouter le signal \xe0 ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSignals")," ",(0,o.kt)("strong",{parentName:"li"},"m\xeame s'il est d\xe9j\xe0 pr\xe9sent"),"."))),(0,o.kt)("li",{parentName:"ul"},"Ajouter le slot \xe0 ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots")))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\xc0 la d\xe9connexion d'un slot : ",(0,o.kt)("inlineCode",{parentName:"p"},"signal.disconnect(&a, &A::m)")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Si le slot est bien pr\xe9sent dans ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots")," on le retire."),(0,o.kt)("li",{parentName:"ul"},"On retire le signal de ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSignals"),", ",(0,o.kt)("em",{parentName:"li"},"une seule fois"),"! (important!)"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Pour d\xe9connecter un signal donn\xe9 d'un objet ",(0,o.kt)("inlineCode",{parentName:"p"},"signal.disconnect(&a)")," :"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Pour chaque slot de ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots"),": si l'objet du slot correspond \xe0 l'objet \xe0 d\xe9connecter: supprimer le slot"),(0,o.kt)("li",{parentName:"ul"},"Si l'objet d\xe9rive de ",(0,o.kt)("inlineCode",{parentName:"li"},"Objet"),", parcourir les signaux de ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSignals"),", d\xe8s le premier signal correspondant au signal \xe0 d\xe9connecter : retirer ",(0,o.kt)("strong",{parentName:"li"},"chaque occurence")," de ce signal."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Pour d\xe9connecter un signal de tous ses slots ",(0,o.kt)("inlineCode",{parentName:"p"},"signal.disconnectAll()")," :"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Pour chacun des slots de ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots")," : Si le slot d\xe9rive de Object alors pour l'objet correspondant retirer le signal de ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSignals")," ",(0,o.kt)("em",{parentName:"li"},"une seule fois"),"."),(0,o.kt)("li",{parentName:"ul"},"Purger ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSlots")))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\xc0 la destruction d'un objet qui d\xe9rive de la classe Object : appliquer le point 7.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Si un objet derive de la classe Objet pour le d\xe9connecter de tous les signaux qui lui sont connect\xe9s : ",(0,o.kt)("inlineCode",{parentName:"p"},"a.deleteConnectedSignals()")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Pour chacun des signaux dans ",(0,o.kt)("inlineCode",{parentName:"li"},"connectedSignals")," : d\xe9connecter l'objet du signal en appliquant 4.")))),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Un probl\xe8me survient dans le cas o\xf9 un signal est un membre d'une classe et qu'il est connect\xe9 \xe0 une m\xe9thode cette m\xeame classe. Observons plus bas\npourquoi et comment y rem\xe9dier.")),(0,o.kt)("p",null,"Consid\xe9rons une instance d'une classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Counter")," ayant pour membre un signal ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged")," connect\xe9 \xe0 une m\xe9thode ",(0,o.kt)("inlineCode",{parentName:"p"},"meth_1")," de cette m\xeame classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Counter"),".\nD'autres signaux globaux ou membres d'instances d'autres classes sont connect\xe9s \xe0 certaines de ces m\xe9thodes : ",(0,o.kt)("inlineCode",{parentName:"p"},"meth_1")," ou ",(0,o.kt)("inlineCode",{parentName:"p"},"meth_2"),'. A la destruction du Counter,\ncelui-ci doit informer tous les signaux qui sont connect\xe9s \xe0 lui : "Je vais mourir, il ne faut plus m\'appeler...!", autrement dit il doit leur demander de se d\xe9connecter\nde lui. Et cela se fait de la mani\xe8re suivante :'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Le destructeur de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Counter")," est appel\xe9 puis celui de la classe de base ",(0,o.kt)("inlineCode",{parentName:"p"},"Object"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Dans le destructeur de la classe de base ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," la fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"deleteConnectedSignals()")," va passer en revue les pointeurs de signaux (",(0,o.kt)("inlineCode",{parentName:"p"},"SaSSignal*"),") et demander \xe0 chacun\nd'eux de se d\xe9connecter de lui comme d\xe9crit plus haut au point 7."),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("img",{alt:"destruction d&#39;un Object",src:t(2108).Z,width:"691",height:"525"}))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Pour les signaux ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"2")," et ",(0,o.kt)("inlineCode",{parentName:"p"},"3")," il n'y a pas de probl\xe8me, mais pour le signal ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged")," la fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"deleteConnectedSignals()")," va demander \xe0 ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged")," de se d\xe9connecter.\nOr le destructeur de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Counter")," aura d\xe9j\xe0 \xe9t\xe9 effectu\xe9 et donc ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged")," n'existe plus!! et le programme plante... Par cons\xe9quent il est indispensable de\nd\xe9connecter le signal ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged")," de tous les objets auxquels il est connect\xe9 (par ",(0,o.kt)("inlineCode",{parentName:"p"},"valueChanged.disconnectAll()"),") ce qui pr\xe9viendra le probl\xe8me \xe9voqu\xe9. De plus, si l'objet\nconnect\xe9 d\xe9rive de la classe ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," il ne r\xe9f\xe9rencera plus le signal valudeChanged dans son propre conteneur ",(0,o.kt)("inlineCode",{parentName:"p"},"connectedSignals")))))}c.isMDXComponent=!0},2108:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/destructeurs-b5a8632df89049bb22ef59b29ba5c8be.png"},6147:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/sas-4d47babeb53d8d787c02edf312c2a457.png"},1896:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/sas2-148515816f0c5023596ff38b4dfa6d21.png"}}]);