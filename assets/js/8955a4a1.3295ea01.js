"use strict";(self.webpackChunksvl_doc=self.webpackChunksvl_doc||[]).push([[708],{3905:(e,a,r)=>{r.d(a,{Zo:()=>c,kt:()=>b});var t=r(7294);function n(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function l(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?l(Object(r),!0).forEach((function(a){n(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function i(e,a){if(null==e)return{};var r,t,n=function(e,a){if(null==e)return{};var r,t,n={},l=Object.keys(e);for(t=0;t<l.length;t++)r=l[t],a.indexOf(r)>=0||(n[r]=e[r]);return n}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)r=l[t],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var o=t.createContext({}),u=function(e){var a=t.useContext(o),r=a;return e&&(r="function"==typeof e?e(a):s(s({},a),e)),r},c=function(e){var a=u(e.components);return t.createElement(o.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var r=e.components,n=e.mdxType,l=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(r),m=n,b=p["".concat(o,".").concat(m)]||p[m]||d[m]||l;return r?t.createElement(b,s(s({ref:a},c),{},{components:r})):t.createElement(b,s({ref:a},c))}));function b(e,a){var r=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var l=r.length,s=new Array(l);s[0]=m;var i={};for(var o in a)hasOwnProperty.call(a,o)&&(i[o]=a[o]);i.originalType=e,i[p]="string"==typeof e?e:n,s[1]=i;for(var u=2;u<l;u++)s[u]=r[u];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},343:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>h,contentTitle:()=>k,default:()=>P,frontMatter:()=>f,metadata:()=>y,toc:()=>N});var t=r(7462),n=r(7294),l=r(3905),s=r(6010),i=r(2389),o=r(7392),u=r(7094),c=r(2466);const p="tabList__CuJ",d="tabItem_LNqP";function m(e){const{lazy:a,block:r,defaultValue:l,values:i,groupId:m,className:b}=e,v=n.Children.map(e.children,(e=>{if((0,n.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=i??v.map((e=>{let{props:{value:a,label:r,attributes:t}}=e;return{value:a,label:r,attributes:t}})),f=(0,o.l)(g,((e,a)=>e.value===a.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const k=null===l?l:l??v.find((e=>e.props.default))?.props.value??v[0].props.value;if(null!==k&&!g.some((e=>e.value===k)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${k}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:h}=(0,u.U)(),[N,x]=(0,n.useState)(k),P=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=m){const e=y[m];null!=e&&e!==N&&g.some((a=>a.value===e))&&x(e)}const w=e=>{const a=e.currentTarget,r=P.indexOf(a),t=g[r].value;t!==N&&(O(a),x(t),null!=m&&h(m,String(t)))},T=e=>{let a=null;switch(e.key){case"Enter":w(e);break;case"ArrowRight":{const r=P.indexOf(e.currentTarget)+1;a=P[r]??P[0];break}case"ArrowLeft":{const r=P.indexOf(e.currentTarget)-1;a=P[r]??P[P.length-1];break}}a?.focus()};return n.createElement("div",{className:(0,s.Z)("tabs-container",p)},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":r},b)},g.map((e=>{let{value:a,label:r,attributes:l}=e;return n.createElement("li",(0,t.Z)({role:"tab",tabIndex:N===a?0:-1,"aria-selected":N===a,key:a,ref:e=>P.push(e),onKeyDown:T,onClick:w},l,{className:(0,s.Z)("tabs__item",d,l?.className,{"tabs__item--active":N===a})}),r??a)}))),a?(0,n.cloneElement)(v.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):n.createElement("div",{className:"margin-top--md"},v.map(((e,a)=>(0,n.cloneElement)(e,{key:a,hidden:e.props.value!==N})))))}function b(e){const a=(0,i.Z)();return n.createElement(m,(0,t.Z)({key:String(a)},e))}const v="tabItem_Ymn6";function g(e){let{children:a,hidden:r,className:t}=e;return n.createElement("div",{role:"tabpanel",className:(0,s.Z)(v,t),hidden:r},a)}const f={sidebar_position:1,description:"parseur de r\xe8gles",title:"RulesParser",sidebar_label:"Utilisation de RulesParser"},k=void 0,y={unversionedId:"RulesParser/RulesParser",id:"RulesParser/RulesParser",title:"RulesParser",description:"parseur de r\xe8gles",source:"@site/docs/RulesParser/RulesParser.mdx",sourceDirName:"RulesParser",slug:"/RulesParser/",permalink:"/svl-doc/docs/RulesParser/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"parseur de r\xe8gles",title:"RulesParser",sidebar_label:"Utilisation de RulesParser"},sidebar:"tutorialSidebar",previous:{title:"RulesParser",permalink:"/svl-doc/docs/category/rulesparser"},next:{title:"RulesParser",permalink:"/svl-doc/docs/RulesParser/code"}},h={},N=[{value:"Transcription d&#39;une grammaire",id:"transcription-dune-grammaire",level:2}],x={toc:N};function P(e){let{components:a,...r}=e;return(0,l.kt)("wrapper",(0,t.Z)({},x,r,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"transcription-dune-grammaire"},"Transcription d'une grammaire"),(0,l.kt)("p",null,"On cherche \xe0 transcrire une cha\xeene texte contenant les r\xe8gles d'une ",(0,l.kt)("em",{parentName:"p"},"grammaire")," en des fonctions \xe9crites en C++ qui permettront,\napr\xe8s compilation, de tester la validit\xe9 d'expressions pour cette grammaire.\nConsid\xe9rons cet exemple de grammaire :"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'string test_grammar = R"(\n   operande: one of\n            a b\n\n   operator: one of\n           + *\n\n   exp:\n     operande\n     operande operator operande\n     exp operator ( exp )\n     exp operator exp\n\n)";\n')),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Chaque r\xe8gle doit \xeatre termin\xe9e par un saut de ligne. (ligne vierge)")),(0,l.kt)("p",null,"Voici des expressions valides ou non valides pour cette grammaire :"),(0,l.kt)(b,{mdxType:"Tabs"},(0,l.kt)(g,{value:"gvalide",label:"Expressions valides",default:!0,mdxType:"TabItem"},(0,l.kt)("ul",null,(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"b")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a+b")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a*b")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"b*(b+a)")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a+a*b*(b+(b*a))+a")))),(0,l.kt)(g,{value:"gnovalide",label:"Expressions non valides",mdxType:"TabItem"},(0,l.kt)("ul",null,(0,l.kt)("li",null,(0,l.kt)("span",{className:"gnvalide"},"c")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a"),(0,l.kt)("span",{className:"gnvalide"},"+c")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a+b"),(0,l.kt)("span",{className:"gnvalide"},"*(b+c)*b")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a+b*(b+a)"),(0,l.kt)("span",{className:"gnvalide"},"*c")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gnvalide"},"(a+b)*c")),(0,l.kt)("li",null,(0,l.kt)("span",{className:"gvalide"},"a"),(0,l.kt)("span",{className:"gnvalide"}," + b"))))),(0,l.kt)("p",null,"La r\xe8gle ne pr\xe9cisant pas qu'il faut ignorer les ",(0,l.kt)("em",{parentName:"p"},"whitespaces"),", on voit comme dans le dernier exemple qu'une expression qui\npourrait para\xeetre valide ne l'est pas si les op\xe9randes ou op\xe9rateurs sont entour\xe9s d'espaces."),(0,l.kt)("p",null,"On voit qu'une expression m\u1ebfme globalement non valide est pars\xe9e jusqu'\xe0 ce qu'on puisse en extraire une partie valide."),(0,l.kt)("p",null,"On initialise le parser avec la grammaire et on lance le parsage :"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"RulesParser parser(test_grammar);\nparser.parse();\n")))}P.isMDXComponent=!0}}]);